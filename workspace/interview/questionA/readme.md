# q1
js执行上下文会自动创建 
1. 全局对象 
2. this关键字

# new的过程发生了什么
1. __proto__是每个对象都有的一个属性，而prototype是函数才会有的属性。 
2. __proto__指向的是当前对象的原型对象，而prototype指向的，是以当前函数作为构造函数构造出来的对象的原型对象。
所有对象字面量都是通过Object()构造出来的,Object.prototype这个对象，它的__proto__指向的是null，然后就没有然后了。
prototype 显式原型 只有函数function才有
__proto__ 隐式原型 所有的都有
1. 每个函数function都有一个prototype，即显式原型(属性)
2. 每个实例对象都有一个__proto__，可称为隐式原型(属性)
3. 对象的隐式原型的值为其对应构造函数的显式原型的值
函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象
对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值

new 的实现原理:
如果函数调用前使用了 new 关键字, 则是调用了构造函数。
这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：

1. 创建一个空对象， 构造函数中的this指向这个空对象
2. 这个新对象被执行[原型]连接
3. 执行这个构造函数， 属性和方法添加到this引用的对象中
4. 如果构造函数中没有返回其他对象，那么就返回这个this，即创建的新对象，否则返回构造函数中返回的对象


## call apply bind
1. apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。
2.  bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。


## arguments
1.arguments对象和Function是分不开的。
2.因为arguments这个对象不能显式创建。
3.arguments对象只有函数开始时才可用。
callee 属性是 arguments 对象的一个成员，仅当相关函数正在执行时才可用。callee 属性的初始值就是正被执行的 Function 对象。实现匿名的递归函数。
### 把arguments转换成一个真正的数组
var args = Array.prototype.slice.call(arguments);


## 深拷贝和浅拷贝  https://juejin.im/post/5b5dcf8351882519790c9a2e
1. 基本数据类型的特点：直接存储在栈(stack)中的数据
2. 引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里

* 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，**无论哪个对象**发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
* 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。**只有引用类型会跟随变化**
* 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。完全拷贝过来，**双方毫不影响**

## 闭包
1. 闭包指的是：能够访问另一个函数作用域的变量的函数
2. 闭包就是一个函数，这个函数能够访问其他函数的作用域中的变量

闭包的原理: 有权限访问  其他函数  的作用域的  函数
1. 阻止作用域被js垃圾回收
2. 创建私有变量
3. 创建块级作用域

## q5数组去重
Set typeof includes map reduce

## 事件委托
